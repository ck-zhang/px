use std::borrow::Cow;
use std::collections::{BTreeMap, HashMap, HashSet};
use std::env;
use std::fs::{self, File};
use std::io::Read;
use std::path::{Path, PathBuf};
use std::process::Command;
use std::str::FromStr;

use crate::context::CommandContext;
use crate::core::runtime as effects;
use crate::core::runtime::artifacts::{dependency_name, select_wheel};
use crate::core::runtime::builder::{builder_identity_for_python, builder_identity_for_runtime};
use crate::core::runtime::cas_env::{
    copy_tree, ensure_profile_env, project_env_owner_id, write_python_shim,
};
use crate::core::runtime::runtime_manager;
use crate::core::tooling::diagnostics;
use crate::outcome::InstallUserError;
use crate::python_sys::{detect_interpreter, detect_interpreter_tags};
use crate::store::cas::{
    archive_dir_canonical, global_store, pkg_build_lookup_key, run_gc_with_env_policy,
    source_lookup_key, ObjectKind, ObjectPayload, OwnerId, OwnerType, PkgBuildHeader, SourceHeader,
};
use crate::store::{
    ensure_sdist_build, ensure_wheel_dist, wheel_build_options_hash, ArtifactRequest, SdistRequest,
};
use crate::tools::disable_proxy_env;
use anyhow::{anyhow, bail, Context, Result};
use hex;
use px_domain::api::{canonicalize_package_name, load_lockfile_optional};
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use sha2::{Digest, Sha256};
use toml_edit::{DocumentMut, Item, Table, Value as TomlValue};
use tracing::warn;
use url::Url;

use super::context::detect_local_site_packages;
use super::context::{
    derive_vcs_version, hatch_drops_local_version, hatch_git_describe_command,
    hatch_prefers_simplified_semver, hatch_version_file, pdm_version_file,
    setuptools_scm_version_file, uses_hatch_vcs, VersionDeriveOptions,
};
use super::plan::project_table;
use super::{build_pythonpath, compute_lock_hash, ManifestSnapshot};

#[cfg(test)]
use px_domain::api::LockSnapshot;

mod editable;
mod markers;
mod refresh;
mod runtime;
mod site;
mod state;
#[cfg(test)]
mod test_support;
mod wheel;

pub(crate) use markers::write_python_environment_markers;
pub(crate) use refresh::refresh_project_site;
pub(crate) use runtime::{detect_runtime_metadata, prepare_project_runtime, RuntimeMetadata};
pub(crate) use site::{select_python_from_site, site_packages_dir};
pub(super) use state::resolve_project_site;
pub(crate) use state::{load_project_state, StoredEnvironment, StoredPython, StoredRuntime};

#[cfg(test)]
pub(super) use editable::load_editable_project_metadata;
#[cfg(test)]
pub(super) use editable::write_sitecustomize;
pub(super) use editable::{
    materialize_wheel_scripts, normalize_project_name, uses_maturin_backend,
};
pub(crate) use editable::write_project_metadata_stub;
#[cfg(test)]
pub(super) use refresh::uv_cli_candidates;
pub(super) use refresh::{
    ensure_uv_seed, has_uv_cli, module_available, project_site_env, uv_seed_required,
};
pub(super) use wheel::ensure_project_wheel_scripts;
#[cfg(test)]
pub(super) use wheel::{
    cached_project_wheel, compute_file_sha256, persist_wheel_metadata, project_build_hash,
    project_wheel_cache_dir,
};

use site::install_python_link;
use state::persist_project_state;

#[cfg(test)]
pub use test_support::materialize_project_site;

pub(crate) const SITE_CUSTOMIZE: &str = r#"# Auto-generated by px. Do not edit.
import os
import sys
import sysconfig
from pathlib import Path

def _collect_allowed_from_pythonpath():
    allowed = []
    env_py = os.environ.get("PYTHONPATH", "")
    for entry in env_py.split(os.pathsep):
        if not entry:
            continue
        allowed.append(entry)
        pth = Path(entry).joinpath("px.pth")
        try:
            with pth.open() as handle:
                for line in handle:
                    trimmed = line.strip()
                    if trimmed:
                        allowed.append(trimmed)
        except OSError:
            continue
    return allowed

def _stdlib_prefixes():
    prefixes = set()
    for key in ("stdlib", "platstdlib"):
        path = sysconfig.get_path(key)
        if path:
            prefixes.add(os.path.normpath(path))
    for attr in ("base_prefix", "base_exec_prefix", "exec_prefix"):
        value = getattr(sys, attr, None)
        if value:
            prefixes.add(os.path.normpath(value))
    return prefixes

_STD_PREFIXES = _stdlib_prefixes()
_ORIG_PYTHONPATH = os.environ.get("PYTHONPATH", "")
_PX_ALLOWED = os.environ.get("PX_ALLOWED_PATHS", "")
_ALLOWED = _collect_allowed_from_pythonpath()
for entry in _PX_ALLOWED.split(os.pathsep):
    if entry and entry not in _ALLOWED:
        _ALLOWED.append(entry)
_PARENT_PYTHONPATH = _PX_ALLOWED if _PX_ALLOWED else _ORIG_PYTHONPATH

_FILTER_PATHS = True
_target_exe = os.environ.get("PX_PYTHON")
if _target_exe:
    try:
        target_real = os.path.realpath(_target_exe)
        current_real = os.path.realpath(sys.executable)
        if os.path.normpath(target_real) != os.path.normpath(current_real):
            _FILTER_PATHS = False
    except Exception:
        _FILTER_PATHS = False

def _allow(path):
    if not path:
        return False
    norm = os.path.normpath(path)
    if os.environ.get("NO_SITE_PACKAGES") and ("site-packages" in norm or "dist-packages" in norm):
        return False
    if "__pypackages__" in norm:
        return True
    for allowed in _ALLOWED:
        try:
            allowed_norm = os.path.normpath(allowed)
        except Exception:
            continue
        if norm == allowed_norm or norm.startswith(allowed_norm + os.sep):
            return True
    for prefix in _STD_PREFIXES:
        if norm == prefix or norm.startswith(prefix + os.sep):
            return True
    return False

if _FILTER_PATHS:
    _new_path = []
    _seen = set()
    _original = list(sys.path)
    _script_dir = sys.path[0] if sys.path else ""
    try:
        _cwd = os.getcwd()
    except Exception:
        _cwd = ""
    if not _script_dir:
        _script_dir = _cwd
    _argv_dir = ""
    try:
        _argv0 = sys.argv[0] if sys.argv else ""
        if _argv0:
            _argv_path = _argv0
            if not os.path.isabs(_argv_path):
                _argv_path = os.path.abspath(_argv_path)
            if os.path.isfile(_argv_path):
                _argv_dir = os.path.dirname(_argv_path)
    except Exception:
        _argv_dir = ""

    def _push(path):
        if not path:
            return
        if path in _seen:
            return
        _seen.add(path)
        _new_path.append(path)

    for path in _ALLOWED:
        _push(path)

    for path in sys.path:
        if _allow(path):
            _push(path)

    if _script_dir:
        _push(_script_dir)
    if _argv_dir:
        _push(_argv_dir)
    if _cwd and _cwd not in _seen:
        _push(_cwd)

    sys.path[:] = _new_path
    # Ensure child processes inherit the base px path set without exploding argv/env size.
    os.environ["PYTHONPATH"] = _PARENT_PYTHONPATH

    _SITE_BIN = Path(__file__).resolve().parent / "bin"
    if not _SITE_BIN.exists():
        current = Path(__file__).resolve().parent
        for _ in range(4):
            candidate = current.parent / "bin"
            if candidate.exists():
                _SITE_BIN = candidate
                break
            current = current.parent
    if _SITE_BIN.exists():
        try:
            import sysconfig as _sysconfig
            _orig_get_path = _sysconfig.get_path
            def _px_get_path(name, scheme=None, vars=None, expand=True):
                if name == "scripts" and scheme is None:
                    return str(_SITE_BIN)
                resolved_scheme = scheme or _sysconfig.get_default_scheme()
                return _orig_get_path(name, scheme=resolved_scheme, vars=vars, expand=expand)
            _sysconfig.get_path = _px_get_path
        except Exception:
            pass
        try:
            current = os.environ.get("PATH", "")
            entries = []
            seen = set()
            def _push_path(value):
                if not value:
                    return
                if value in seen:
                    return
                seen.add(value)
                entries.append(value)

            _push_path(str(_SITE_BIN))
            for allowed in _ALLOWED:
                try:
                    p = Path(allowed)
                    if p.name in ("site-packages", "dist-packages"):
                        candidate = p.parent / "bin"
                        if candidate.exists():
                            _push_path(str(candidate))
                except Exception:
                    pass

            for p in current.split(os.pathsep):
                _push_path(p)

            os.environ["PATH"] = os.pathsep.join(entries)
        except Exception:
            pass
else:
    px_allowed = set(_ALLOWED)
    sys.path[:] = [path for path in sys.path if path not in px_allowed]

if "" in sys.path:
    try:
        sys.path.remove("")
    except Exception:
        pass

_debug_dump = os.environ.get("PX_DEBUG_SITE_PATHS")
if _debug_dump:
    try:
        Path(_debug_dump).write_text("\n".join(sys.path))
    except Exception:
        pass

try:
    _perf_baseline = os.environ.get("PX_PYTEST_PERF_BASELINE")
    if _perf_baseline:
        import pytest_perf.runner as _perf_runner
        def _px_perf_upstream_url(extras="", control=None):
            spec = _perf_baseline.replace("{extras}", extras)
            if control and "git+" in spec:
                return spec + f"@{control}"
            return spec
        _perf_runner.upstream_url = _px_perf_upstream_url
except Exception:
    pass

"#;
pub(super) const SETUPTOOLS_SEED_VERSION: &str = "80.9.0";
pub(super) const UV_SEED_VERSION: &str = "0.9.15";
pub(super) const PACKAGING_SEED_VERSION: &str = "24.1";
pub(super) const PYPROJECT_HOOKS_SEED_VERSION: &str = "1.2.0";
pub(super) const BUILD_SEED_VERSION: &str = "1.2.2.post1";
pub(super) const TOMLI_SEED_VERSION: &str = "2.0.1";
#[cfg(unix)]
fn set_exec_permissions(path: &Path) {
    use std::os::unix::fs::PermissionsExt;
    let _ = fs::set_permissions(path, fs::Permissions::from_mode(0o755));
}

#[cfg(not(unix))]
fn set_exec_permissions(_path: &Path) {
    // No-op on non-Unix; rely on defaults.
}

fn parse_python_version(version: &str) -> Option<(String, String)> {
    let mut parts = version.split('.');
    let major = parts.next()?.to_string();
    let minor = parts.next().unwrap_or_default().to_string();
    if major.is_empty() || minor.is_empty() {
        None
    } else {
        Some((major, minor))
    }
}
