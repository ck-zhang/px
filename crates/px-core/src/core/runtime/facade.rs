use std::fmt::Write as _;
use std::{
    collections::{HashMap, HashSet},
    env, fmt, fs,
    fs::File,
    io::Read,
    path::{Path, PathBuf},
    process::Command,
    str::FromStr,
};

use crate::context::{CommandContext, CommandInfo};
use crate::diagnostics::commands as diag_commands;
use crate::effects;
use crate::outcome::{CommandStatus, ExecutionOutcome, InstallUserError};
use crate::process::RunOutput;
use crate::progress::ProgressReporter;
use crate::python_sys::{detect_interpreter, detect_interpreter_tags, detect_marker_environment};
use crate::tools::disable_proxy_env;
use crate::traceback::{analyze_python_traceback, TracebackContext};
use anyhow::{anyhow, bail, Context, Result};
use pep508_rs::MarkerEnvironment;
use px_domain::{
    analyze_lock_diff, autopin_pin_key, autopin_spec_key, detect_lock_drift, format_specifier,
    load_lockfile_optional, marker_applies, merge_resolved_dependencies, render_lockfile, resolve,
    spec_requires_pin, verify_locked_artifacts, AutopinEntry, InstallOverride, LockSnapshot,
    PinSpec, ProjectSnapshot, PxOptions, ResolverRequest, ResolverTags,
};
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use sha2::{Digest, Sha256};
use toml_edit::{Array, DocumentMut, Item, Table, TomlError, Value as TomlValue};
use tracing::warn;

use super::artifacts::{ensure_exact_pins, parse_exact_pin, resolve_pins};
use crate::effects::Effects;
use crate::runtime_manager;

pub(crate) const PX_VERSION: &str = env!("CARGO_PKG_VERSION");
const SITE_CUSTOMIZE: &str = r#"# Auto-generated by px. Do not edit.
import os
import sys
import sysconfig
from pathlib import Path

def _stdlib_prefixes():
    prefixes = set()
    for key in ("stdlib", "platstdlib"):
        path = sysconfig.get_path(key)
        if path:
            prefixes.add(os.path.normpath(path))
    for attr in ("base_prefix", "base_exec_prefix", "exec_prefix"):
        value = getattr(sys, attr, None)
        if value:
            prefixes.add(os.path.normpath(value))
    return prefixes

_STD_PREFIXES = _stdlib_prefixes()
_PX_ALLOWED = os.environ.get("PX_ALLOWED_PATHS", "")
_ALLOWED = [p for p in _PX_ALLOWED.split(os.pathsep) if p]

_FILTER_PATHS = True
_target_exe = os.environ.get("PX_PYTHON")
if _target_exe:
    try:
        target_real = os.path.realpath(_target_exe)
        current_real = os.path.realpath(sys.executable)
        if os.path.normpath(target_real) != os.path.normpath(current_real):
            _FILTER_PATHS = False
    except Exception:
        _FILTER_PATHS = False

def _allow(path):
    if not path:
        return False
    norm = os.path.normpath(path)
    if os.environ.get("NO_SITE_PACKAGES") and ("site-packages" in norm or "dist-packages" in norm):
        return False
    if "__pypackages__" in norm:
        return True
    for prefix in _STD_PREFIXES:
        if norm == prefix or norm.startswith(prefix + os.sep):
            return True
    return False

if _FILTER_PATHS:
    _new_path = []
    _seen = set()
    _script_dir = sys.path[0] if sys.path else ""

    def _push(path):
        if not path:
            return
        if path in _seen:
            return
        _seen.add(path)
        _new_path.append(path)

    for path in _ALLOWED:
        _push(path)

    for path in sys.path:
        if _allow(path):
            _push(path)

    if _script_dir:
        _push(_script_dir)

    sys.path[:] = _new_path
    # Ensure child processes inherit the px path set instead of a mutated sys.path
    os.environ["PYTHONPATH"] = _PX_ALLOWED

    _SITE_BIN = Path(__file__).resolve().parent / "bin"
    if not _SITE_BIN.exists():
        current = Path(__file__).resolve().parent
        for _ in range(4):
            candidate = current.parent / "bin"
            if candidate.exists():
                _SITE_BIN = candidate
                break
            current = current.parent
    if _SITE_BIN.exists():
        try:
            import sysconfig as _sysconfig
            _orig_get_path = _sysconfig.get_path
            def _px_get_path(name, scheme=None, vars=None, expand=True):
                if name == "scripts" and scheme is None:
                    return str(_SITE_BIN)
                resolved_scheme = scheme or _sysconfig.get_default_scheme()
                return _orig_get_path(name, scheme=resolved_scheme, vars=vars, expand=expand)
            _sysconfig.get_path = _px_get_path
        except Exception:
            pass
        try:
            current = os.environ.get("PATH", "")
            entries = [str(_SITE_BIN)] + [p for p in current.split(os.pathsep) if p]
            os.environ["PATH"] = os.pathsep.join(entries)
        except Exception:
            pass
else:
    px_allowed = set(_ALLOWED)
    sys.path[:] = [path for path in sys.path if path not in px_allowed]

"#;

pub(crate) type ManifestSnapshot = ProjectSnapshot;

#[cfg(unix)]
fn set_exec_permissions(path: &Path) {
    use std::os::unix::fs::PermissionsExt;
    let _ = fs::set_permissions(path, fs::Permissions::from_mode(0o755));
}

#[cfg(not(unix))]
fn set_exec_permissions(_path: &Path) {
    // No-op on non-Unix; rely on defaults.
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
pub enum CommandGroup {
    Init,
    Add,
    Remove,
    Sync,
    Update,
    Run,
    Test,
    Fmt,
    Build,
    Publish,
    Migrate,
    Status,
    Why,
    Tool,
    Python,
}

impl fmt::Display for CommandGroup {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let name = match self {
            CommandGroup::Init => "init",
            CommandGroup::Add => "add",
            CommandGroup::Remove => "remove",
            CommandGroup::Sync => "sync",
            CommandGroup::Update => "update",
            CommandGroup::Run => "run",
            CommandGroup::Test => "test",
            CommandGroup::Fmt => "fmt",
            CommandGroup::Build => "build",
            CommandGroup::Publish => "publish",
            CommandGroup::Migrate => "migrate",
            CommandGroup::Status => "status",
            CommandGroup::Why => "why",
            CommandGroup::Tool => "tool",
            CommandGroup::Python => "python",
        };
        f.write_str(name)
    }
}

pub const MISSING_PROJECT_MESSAGE: &str =
    "No px project found. Run `px init` in your project directory first.";
pub const MISSING_PROJECT_HINT: &str = "Run `px init` in your project directory first.";

pub(crate) struct InstallOutcome {
    pub(crate) state: InstallState,
    pub(crate) lockfile: String,
    pub(crate) drift: Vec<String>,
    #[allow(dead_code)]
    pub(crate) verified: bool,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub(crate) enum InstallState {
    Installed,
    UpToDate,
    Drift,
    MissingLock,
}

pub fn lock_is_fresh(snapshot: &ManifestSnapshot) -> Result<bool> {
    let marker_env = marker_env_for_snapshot(snapshot);
    match load_lockfile_optional(&snapshot.lock_path)? {
        Some(lock) => {
            if !detect_lock_drift(snapshot, &lock, marker_env.as_ref()).is_empty() {
                return Ok(false);
            }
            if let Some(fingerprint) = &lock.manifest_fingerprint {
                Ok(fingerprint == &snapshot.manifest_fingerprint)
            } else {
                Ok(true)
            }
        }
        None => Ok(false),
    }
}

pub(crate) fn relative_path_str(path: &Path, root: &Path) -> String {
    path.strip_prefix(root)
        .unwrap_or(path)
        .display()
        .to_string()
}

pub(crate) fn manifest_snapshot() -> Result<ManifestSnapshot> {
    ProjectSnapshot::read_current()
}

pub(crate) fn manifest_snapshot_at(root: &Path) -> Result<ManifestSnapshot> {
    ProjectSnapshot::read_from(root)
}

fn runtime_marker_environment(snapshot: &ManifestSnapshot) -> Result<MarkerEnvironment> {
    let runtime = prepare_project_runtime(snapshot)?;
    let resolver_env = detect_marker_environment(&runtime.record.path)?;
    resolver_env.to_marker_environment()
}

pub fn marker_env_for_snapshot(snapshot: &ManifestSnapshot) -> Option<MarkerEnvironment> {
    runtime_marker_environment(snapshot).ok().or_else(|| {
        detect_interpreter()
            .ok()
            .and_then(|python| detect_marker_environment(&python).ok())
            .and_then(|env| env.to_marker_environment().ok())
    })
}

pub(crate) fn install_snapshot(
    ctx: &CommandContext,
    snapshot: &ManifestSnapshot,
    frozen: bool,
    override_pins: Option<&InstallOverride>,
) -> Result<InstallOutcome> {
    let mut snapshot = snapshot.clone();
    let lockfile = snapshot.lock_path.display().to_string();
    let _ = prepare_project_runtime(&snapshot)?;

    if frozen {
        return verify_lock(&snapshot);
    }

    if lock_is_fresh(&snapshot)? {
        Ok(InstallOutcome {
            state: InstallState::UpToDate,
            lockfile,
            drift: Vec::new(),
            verified: false,
        })
    } else {
        if let Some(parent) = snapshot.lock_path.parent() {
            fs::create_dir_all(parent)?;
        }
        let mut manifest_updated = false;
        let mut manifest_dependencies = if let Some(override_data) = override_pins {
            override_data.dependencies.clone()
        } else {
            snapshot.dependencies.clone()
        };
        let mut requirements =
            merge_requirements(&manifest_dependencies, &snapshot.group_dependencies);
        let marker_env = ctx.marker_environment()?;
        let mut resolved_override = None;
        if override_pins.is_none() && ctx.config().resolver.enabled {
            let resolved = resolve_dependencies(ctx, &snapshot)?;
            if !resolved.specs.is_empty() {
                manifest_dependencies = merge_resolved_dependencies(
                    &manifest_dependencies,
                    &resolved.specs,
                    &marker_env,
                );
                persist_resolved_dependencies(&snapshot, &manifest_dependencies)?;
                manifest_updated = true;
                requirements =
                    merge_requirements(&manifest_dependencies, &snapshot.group_dependencies);
            }
            resolved_override = Some(resolved.pins);
        }
        let pins = if let Some(override_data) = override_pins {
            let mut pins: Vec<PinSpec> = override_data
                .pins
                .iter()
                .filter(|pin| marker_applies(&pin.specifier, &marker_env))
                .cloned()
                .collect();
            if pins.is_empty() {
                for spec in &requirements {
                    if !marker_applies(spec, &marker_env) {
                        continue;
                    }
                    pins.push(parse_exact_pin(spec)?);
                }
            }
            pins
        } else {
            match resolved_override {
                Some(pins) => pins,
                None => ensure_exact_pins(&marker_env, &requirements)?,
            }
        };
        if manifest_updated {
            snapshot = manifest_snapshot_at(&snapshot.root).map_err(|err| {
                InstallUserError::new(
                    "failed to reload project manifest",
                    json!({ "error": err.to_string() }),
                )
            })?;
        }
        let resolved = resolve_pins(ctx, &pins, ctx.config().resolver.force_sdist)?;
        let contents = render_lockfile(&snapshot, &resolved, PX_VERSION)?;
        fs::write(&snapshot.lock_path, contents)?;
        Ok(InstallOutcome {
            state: InstallState::Installed,
            lockfile,
            drift: Vec::new(),
            verified: false,
        })
    }
}

fn merge_requirements(base: &[String], groups: &[String]) -> Vec<String> {
    let mut merged = base.to_vec();
    merged.extend(groups.iter().cloned());
    merged.sort();
    merged.dedup();
    merged
}

pub(crate) fn refresh_project_site(
    snapshot: &ManifestSnapshot,
    ctx: &CommandContext,
) -> Result<()> {
    let _ = prepare_project_runtime(snapshot)?;
    let lock = load_lockfile_optional(&snapshot.lock_path)?.ok_or_else(|| {
        anyhow!(
            "px sync: lockfile missing at {}",
            snapshot.lock_path.display()
        )
    })?;
    let runtime = detect_runtime_metadata(ctx, snapshot)?;
    let lock_id = match lock.lock_id.clone() {
        Some(value) => value,
        None => compute_lock_hash(&snapshot.lock_path)?,
    };
    let env_id = compute_environment_id(&lock_id, &runtime);
    let env_root = snapshot.root.join(".px").join("envs").join(&env_id);
    ctx.fs().create_dir_all(&env_root)?;
    let site_dir = env_root.join("site");
    ctx.fs().create_dir_all(&site_dir)?;
    let site_packages = site_packages_dir(&site_dir, &runtime.version);
    ctx.fs().create_dir_all(&site_packages)?;
    let env_python = site_dir.join("bin").join("python");
    materialize_project_site(
        &site_dir,
        &site_packages,
        &lock,
        Some(&env_python),
        ctx.fs(),
    )?;
    let env_python = write_python_environment_markers(&site_dir, &runtime, ctx.fs())?;
    let canonical_site = ctx.fs().canonicalize(&site_dir).unwrap_or(site_dir.clone());
    let runtime_state = StoredRuntime {
        path: runtime.path.clone(),
        version: runtime.version.clone(),
        platform: runtime.platform.clone(),
    };
    let env_state = StoredEnvironment {
        id: env_id,
        lock_id,
        platform: runtime.platform.clone(),
        site_packages: canonical_site.display().to_string(),
        python: StoredPython {
            path: env_python.display().to_string(),
            version: runtime.version.clone(),
        },
    };
    persist_project_state(ctx.fs(), &snapshot.root, env_state, runtime_state)
}

pub fn materialize_project_site(
    site_dir: &Path,
    site_packages: &Path,
    lock: &LockSnapshot,
    python: Option<&Path>,
    fs: &dyn effects::FileSystem,
) -> Result<()> {
    fs.create_dir_all(site_dir)?;
    fs.create_dir_all(site_packages)?;
    let pth_path = site_dir.join("px.pth");
    let pth_copy_path = site_packages.join("px.pth");
    let bin_dir = site_dir.join("bin");
    fs.create_dir_all(&bin_dir)?;
    let mut entries = Vec::new();
    for dep in &lock.resolved {
        let Some(artifact) = &dep.artifact else {
            continue;
        };
        if artifact.cached_path.is_empty() {
            continue;
        }
        let wheel_path = PathBuf::from(&artifact.cached_path);
        if !wheel_path.exists() {
            continue;
        }
        let dist_path = wheel_path.with_extension("dist");
        let entry_path = if dist_path.exists() {
            dist_path
        } else {
            wheel_path
        };
        let _ = materialize_wheel_scripts(&entry_path, &bin_dir, python);
        let canonical = entry_path.canonicalize().unwrap_or(entry_path);
        entries.push(canonical);
    }

    entries.sort();
    entries.dedup();

    let mut contents = entries
        .iter()
        .map(|path| path.display().to_string())
        .collect::<Vec<_>>()
        .join("\n");
    if !contents.is_empty() {
        contents.push('\n');
    }
    fs.write(&pth_path, contents.as_bytes())?;
    fs.write(&pth_copy_path, contents.as_bytes())?;
    write_sitecustomize(site_dir, Some(site_packages), fs)?;
    Ok(())
}

fn materialize_wheel_scripts(
    artifact_path: &Path,
    bin_dir: &Path,
    python: Option<&Path>,
) -> Result<()> {
    fs::create_dir_all(bin_dir)?;
    let python_shebang = python
        .map(|path| path.display().to_string())
        .unwrap_or_else(|| "/usr/bin/env python3".to_string());
    let write_entrypoint = |name: &str, module: &str, callable: &str| -> Result<()> {
        let script_path = bin_dir.join(name);
        let parts: Vec<String> = callable
            .split('.')
            .filter(|part| !part.is_empty())
            .map(ToString::to_string)
            .collect();
        let parts_repr = format!("{parts:?}");
        let contents = format!(
            "#!{python_shebang}\nimport importlib\nimport sys\n\ndef _load():\n    module = importlib.import_module({module:?})\n    target = module\n    for attr in {parts_repr}:\n        target = getattr(target, attr)\n    return target\n\nif __name__ == '__main__':\n    sys.exit(_load()())\n"
        );
        fs::write(&script_path, contents)?;
        set_exec_permissions(&script_path);
        Ok(())
    };
    if artifact_path.extension().is_some_and(|ext| ext == "dist") && artifact_path.is_dir() {
        let entry_points = fs::read_dir(artifact_path)?
            .filter_map(|entry| entry.ok())
            .map(|entry| entry.path())
            .find(|path| path.extension().is_some_and(|ext| ext == "dist-info"))
            .and_then(|dist_info| {
                let ep = dist_info.join("entry_points.txt");
                ep.exists().then_some(ep)
            });
        if let Some(ep_path) = entry_points {
            if let Ok(contents) = fs::read_to_string(&ep_path) {
                let mut section = String::new();
                for line in contents.lines() {
                    let trimmed = line.trim();
                    if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with(';') {
                        continue;
                    }
                    if trimmed.starts_with('[') && trimmed.ends_with(']') {
                        section = trimmed
                            .trim_start_matches('[')
                            .trim_end_matches(']')
                            .to_string();
                        continue;
                    }
                    if section != "console_scripts" && section != "gui_scripts" {
                        continue;
                    }
                    if let Some((name, target)) = trimmed.split_once('=') {
                        let entry_name = name.trim();
                        let raw_target = target.trim();
                        let target_value = raw_target
                            .split_whitespace()
                            .next()
                            .unwrap_or(raw_target)
                            .trim();
                        if let Some((module, callable)) = target_value.split_once(':') {
                            let _ = write_entrypoint(entry_name, module.trim(), callable.trim());
                        }
                    }
                }
            }
        }

        let script_dirs: Vec<PathBuf> = fs::read_dir(artifact_path)?
            .filter_map(|entry| entry.ok())
            .map(|entry| entry.path())
            .filter(|path| {
                path.file_name()
                    .and_then(|name| name.to_str())
                    .map(|name| name.ends_with(".data"))
                    .unwrap_or(false)
            })
            .map(|data_dir| data_dir.join("scripts"))
            .filter(|path| path.exists())
            .collect();
        for dir in script_dirs {
            for entry in fs::read_dir(&dir)? {
                let entry = entry?;
                if entry.file_type()?.is_file() {
                    let dest = bin_dir.join(entry.file_name());
                    fs::copy(entry.path(), &dest)?;
                    set_exec_permissions(&dest);
                }
            }
        }
        return Ok(());
    }

    if artifact_path.extension().is_some_and(|ext| ext == "whl") && artifact_path.is_file() {
        let file = File::open(artifact_path)?;
        let mut archive = zip::ZipArchive::new(file)?;

        if let Some(idx) = (0..archive.len()).find(|i| {
            archive
                .by_index(*i)
                .ok()
                .map(|file| file.name().ends_with("entry_points.txt"))
                .unwrap_or(false)
        }) {
            if let Ok(mut ep_file) = archive.by_index(idx) {
                let mut contents = String::new();
                ep_file.read_to_string(&mut contents)?;
                let mut section = String::new();
                for line in contents.lines() {
                    let trimmed = line.trim();
                    if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with(';') {
                        continue;
                    }
                    if trimmed.starts_with('[') && trimmed.ends_with(']') {
                        section = trimmed
                            .trim_start_matches('[')
                            .trim_end_matches(']')
                            .to_string();
                        continue;
                    }
                    if section != "console_scripts" && section != "gui_scripts" {
                        continue;
                    }
                    if let Some((name, target)) = trimmed.split_once('=') {
                        let entry_name = name.trim();
                        let raw_target = target.trim();
                        let target_value = raw_target
                            .split_whitespace()
                            .next()
                            .unwrap_or(raw_target)
                            .trim();
                        if let Some((module, callable)) = target_value.split_once(':') {
                            let _ = write_entrypoint(entry_name, module.trim(), callable.trim());
                        }
                    }
                }
            }
        }

        for i in 0..archive.len() {
            let mut file = archive.by_index(i)?;
            let name = file.name().to_string();
            if !name.contains(".data/scripts/") || name.ends_with('/') {
                continue;
            }
            if let Some((_, script_name)) = name.rsplit_once(".data/scripts/") {
                let dest = bin_dir.join(script_name);
                let mut contents = Vec::new();
                file.read_to_end(&mut contents)?;
                fs::write(&dest, contents)?;
                set_exec_permissions(&dest);
            }
        }
    }

    Ok(())
}

fn write_sitecustomize(
    site_dir: &Path,
    extra_dir: Option<&Path>,
    fs: &dyn effects::FileSystem,
) -> Result<()> {
    let path = site_dir.join("sitecustomize.py");
    fs.write(&path, SITE_CUSTOMIZE.as_bytes())?;
    if let Some(extra) = extra_dir {
        fs.create_dir_all(extra)?;
        fs.write(&extra.join("sitecustomize.py"), SITE_CUSTOMIZE.as_bytes())?;
    }
    Ok(())
}

pub(crate) fn write_python_environment_markers(
    site_dir: &Path,
    runtime: &RuntimeMetadata,
    fs: &dyn effects::FileSystem,
) -> Result<PathBuf> {
    let bin_dir = site_dir.join("bin");
    fs.create_dir_all(&bin_dir)?;

    let runtime_path = PathBuf::from(&runtime.path);
    let canonical_runtime = fs
        .canonicalize(&runtime_path)
        .unwrap_or_else(|_| runtime_path.clone());
    let home = canonical_runtime
        .parent()
        .and_then(|parent| parent.parent())
        .unwrap_or_else(|| canonical_runtime.parent().unwrap_or(Path::new("")));
    let pyvenv_cfg = format!(
        "home = {}\ninclude-system-site-packages = false\nversion = {}\n",
        home.display(),
        runtime.version
    );
    fs.write(&site_dir.join("pyvenv.cfg"), pyvenv_cfg.as_bytes())?;

    let mut names = vec!["python".to_string(), "python3".to_string()];
    if let Some((major, minor)) = parse_python_version(&runtime.version) {
        names.push(format!("python{major}"));
        names.push(format!("python{major}.{minor}"));
    }
    for name in names {
        let dest = bin_dir.join(&name);
        install_python_link(&canonical_runtime, &dest)?;
    }
    Ok(bin_dir.join("python"))
}

fn parse_python_version(version: &str) -> Option<(String, String)> {
    let mut parts = version.split('.');
    let major = parts.next()?.to_string();
    let minor = parts.next().unwrap_or_default().to_string();
    if major.is_empty() || minor.is_empty() {
        None
    } else {
        Some((major, minor))
    }
}

pub(crate) fn site_packages_dir(site_dir: &Path, runtime_version: &str) -> PathBuf {
    if let Some((major, minor)) = parse_python_version(runtime_version) {
        site_dir
            .join("lib")
            .join(format!("python{major}.{minor}"))
            .join("site-packages")
    } else {
        site_dir.join("site-packages")
    }
}

fn install_python_link(source: &Path, dest: &Path) -> Result<()> {
    if dest.exists() {
        let _ = fs::remove_file(dest);
    }
    if let Some(parent) = dest.parent() {
        fs::create_dir_all(parent)?;
    }
    #[cfg(unix)]
    {
        use std::os::unix::fs::symlink;
        if symlink(source, dest).is_ok() {
            return Ok(());
        }
    }
    if std::fs::hard_link(source, dest).is_ok() {
        return Ok(());
    }
    fs::copy(source, dest)?;
    set_exec_permissions(dest);
    Ok(())
}

fn select_python_from_site(
    site_bin: &Option<PathBuf>,
    runtime_path: &str,
    runtime_version: &str,
) -> String {
    if let Some(bin) = site_bin {
        let mut candidates = vec![bin.join("python"), bin.join("python3")];
        if let Some((major, minor)) = parse_python_version(runtime_version) {
            candidates.push(bin.join(format!("python{major}")));
            candidates.push(bin.join(format!("python{major}.{minor}")));
        }
        if let Some(found) = candidates.into_iter().find(|path| path.exists()) {
            return found.display().to_string();
        }
    }
    runtime_path.to_string()
}

fn persist_project_state(
    filesystem: &dyn effects::FileSystem,
    project_root: &Path,
    env: StoredEnvironment,
    runtime: StoredRuntime,
) -> Result<()> {
    let mut state = load_project_state(filesystem, project_root)?;
    state.current_env = Some(env);
    state.runtime = Some(runtime);
    write_project_state(filesystem, project_root, &state)
}

pub(crate) fn load_project_state(
    filesystem: &dyn effects::FileSystem,
    project_root: &Path,
) -> Result<ProjectState> {
    let path = project_root.join(".px").join("state.json");
    match filesystem.read_to_string(&path) {
        Ok(contents) => {
            let state: ProjectState = serde_json::from_str(&contents)
                .with_context(|| format!("failed to parse {}", path.display()))?;
            validate_project_state(&state)?;
            Ok(state)
        }
        Err(err) => {
            if filesystem.metadata(&path).is_ok() {
                Err(err)
            } else {
                Ok(ProjectState::default())
            }
        }
    }
}

fn write_project_state(
    filesystem: &dyn effects::FileSystem,
    project_root: &Path,
    state: &ProjectState,
) -> Result<()> {
    let path = project_root.join(".px").join("state.json");
    let mut contents = serde_json::to_vec_pretty(state)?;
    contents.push(b'\n');
    if let Some(dir) = path.parent() {
        filesystem.create_dir_all(dir)?;
    }
    let tmp_path = path.with_extension("json.tmp");
    filesystem.write(&tmp_path, &contents)?;
    std::fs::rename(&tmp_path, &path).with_context(|| format!("writing {}", path.display()))?;
    Ok(())
}

fn validate_project_state(state: &ProjectState) -> Result<()> {
    if let Some(env) = &state.current_env {
        if env.id.trim().is_empty() || env.lock_id.trim().is_empty() {
            bail!("invalid project state: missing environment identity");
        }
        if env.site_packages.trim().is_empty() {
            bail!("invalid project state: missing site-packages path");
        }
        if env.python.path.trim().is_empty() || env.python.version.trim().is_empty() {
            bail!("invalid project state: missing python metadata");
        }
    }
    if let Some(runtime) = &state.runtime {
        if runtime.path.trim().is_empty()
            || runtime.version.trim().is_empty()
            || runtime.platform.trim().is_empty()
        {
            bail!("invalid project runtime metadata");
        }
    }
    Ok(())
}

fn resolve_project_site(
    filesystem: &dyn effects::FileSystem,
    project_root: &Path,
) -> Result<Option<PathBuf>> {
    let state = load_project_state(filesystem, project_root)?;
    if let Some(env) = state.current_env {
        let path = PathBuf::from(env.site_packages);
        if path.exists() {
            return Ok(Some(path));
        }
    }
    let fallback = project_root.join(".px").join("site");
    if fallback.exists() {
        Ok(Some(fallback))
    } else {
        Ok(None)
    }
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub(crate) struct ProjectState {
    #[serde(default)]
    pub(crate) current_env: Option<StoredEnvironment>,
    #[serde(default)]
    pub(crate) runtime: Option<StoredRuntime>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct StoredEnvironment {
    pub(crate) id: String,
    #[serde(alias = "lock_hash")]
    pub(crate) lock_id: String,
    pub(crate) platform: String,
    pub(crate) site_packages: String,
    pub(crate) python: StoredPython,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub(crate) struct StoredRuntime {
    pub(crate) path: String,
    pub(crate) version: String,
    pub(crate) platform: String,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct StoredPython {
    pub(crate) path: String,
    pub(crate) version: String,
}

#[derive(Clone, Debug)]
pub(crate) struct RuntimeMetadata {
    pub(crate) path: String,
    pub(crate) version: String,
    pub(crate) platform: String,
}

pub(crate) fn prepare_project_runtime(
    snapshot: &ManifestSnapshot,
) -> Result<runtime_manager::RuntimeSelection> {
    if let Ok(explicit) = env::var("PX_RUNTIME_PYTHON") {
        if let Ok(details) = runtime_manager::inspect_python(Path::new(&explicit)) {
            let requirement = snapshot
                .python_override
                .as_deref()
                .unwrap_or(&snapshot.python_requirement);
            if let (Ok(specs), Ok(version)) = (
                pep440_rs::VersionSpecifiers::from_str(requirement),
                pep440_rs::Version::from_str(&details.full_version),
            ) {
                if specs.contains(&version) {
                    let channel = runtime_manager::format_channel(&details.full_version)
                        .unwrap_or_else(|_| requirement.to_string());
                    let record = runtime_manager::RuntimeRecord {
                        version: channel,
                        full_version: details.full_version,
                        path: details.executable,
                        default: false,
                    };
                    let selection = runtime_manager::RuntimeSelection {
                        record,
                        source: runtime_manager::RuntimeSource::Explicit,
                    };
                    env::set_var("PX_RUNTIME_PYTHON", &selection.record.path);
                    return Ok(selection);
                }
            }
        }
    }

    let selection = runtime_manager::resolve_runtime(
        snapshot.python_override.as_deref(),
        &snapshot.python_requirement,
    )
    .map_err(|err| {
        InstallUserError::new(
            "python runtime unavailable",
            json!({
                "hint": err.to_string(),
                "reason": "missing_runtime",
            }),
        )
    })?;
    env::set_var("PX_RUNTIME_PYTHON", &selection.record.path);
    Ok(selection)
}

pub(crate) fn detect_runtime_metadata(
    ctx: &CommandContext,
    snapshot: &ManifestSnapshot,
) -> Result<RuntimeMetadata> {
    let path = ctx.python_runtime().detect_interpreter()?;
    let version = probe_python_version(ctx, snapshot, &path)?;
    let tags = detect_interpreter_tags(&path)?;
    let platform = tags
        .platform
        .first()
        .cloned()
        .unwrap_or_else(|| "any".to_string());
    Ok(RuntimeMetadata {
        path,
        version,
        platform,
    })
}

fn compute_environment_id(lock_id: &str, runtime: &RuntimeMetadata) -> String {
    let mut hasher = Sha256::new();
    hasher.update(lock_id.as_bytes());
    hasher.update(runtime.version.as_bytes());
    hasher.update(runtime.platform.as_bytes());
    hasher.update(runtime.path.as_bytes());
    let digest = format!("{:x}", hasher.finalize());
    let short = &digest[..digest.len().min(16)];
    format!("env-{short}")
}

pub(crate) fn compute_lock_hash(lock_path: &Path) -> Result<String> {
    let contents = fs::read(lock_path)?;
    let mut hasher = Sha256::new();
    hasher.update(contents);
    Ok(format!("{:x}", hasher.finalize()))
}

fn probe_python_version(
    ctx: &CommandContext,
    snapshot: &ManifestSnapshot,
    python: &str,
) -> Result<String> {
    const SCRIPT: &str =
        "import json, platform; print(json.dumps({'version': platform.python_version()}))";
    let args = vec!["-c".to_string(), SCRIPT.to_string()];
    let output = ctx
        .python_runtime()
        .run_command(python, &args, &[], &snapshot.root)?;
    if output.code != 0 {
        return Err(anyhow!("python exited with {}", output.code));
    }
    let payload: RuntimeProbe =
        serde_json::from_str(output.stdout.trim()).context("invalid runtime probe payload")?;
    Ok(payload.version)
}

#[derive(Deserialize)]
struct RuntimeProbe {
    version: String,
}

fn verify_lock(snapshot: &ManifestSnapshot) -> Result<InstallOutcome> {
    let lockfile = snapshot.lock_path.display().to_string();
    let marker_env = marker_env_for_snapshot(snapshot);
    match load_lockfile_optional(&snapshot.lock_path)? {
        Some(lock) => {
            let report = analyze_lock_diff(snapshot, &lock, marker_env.as_ref());
            let mut drift = report.to_messages();
            if drift.is_empty() {
                drift = verify_locked_artifacts(&lock);
            }
            if drift.is_empty() {
                Ok(InstallOutcome {
                    state: InstallState::UpToDate,
                    lockfile,
                    drift,
                    verified: true,
                })
            } else {
                Ok(InstallOutcome {
                    state: InstallState::Drift,
                    lockfile,
                    drift,
                    verified: true,
                })
            }
        }
        None => Ok(InstallOutcome {
            state: InstallState::MissingLock,
            lockfile,
            drift: Vec::new(),
            verified: true,
        }),
    }
}

pub(crate) struct ResolvedSpecOutput {
    pub(crate) specs: Vec<String>,
    pub(crate) pins: Vec<PinSpec>,
}

fn resolve_dependencies(
    ctx: &CommandContext,
    snapshot: &ManifestSnapshot,
) -> Result<ResolvedSpecOutput> {
    resolve_dependencies_with_effects(ctx.effects(), snapshot, true)
}

pub(crate) fn resolve_dependencies_with_effects(
    effects: &dyn Effects,
    snapshot: &ManifestSnapshot,
    show_progress: bool,
) -> Result<ResolvedSpecOutput> {
    let spinner = show_progress.then(|| ProgressReporter::spinner("Resolving dependencies"));
    let python = effects.python().detect_interpreter()?;
    let tags = detect_interpreter_tags(&python)?;
    let resolver_env = detect_marker_environment(&python)?;
    let marker_env = resolver_env
        .to_marker_environment()
        .map_err(|err| anyhow!("invalid marker environment: {err}"))?;
    let cache_dir = effects.cache().resolve_store_path()?.path;
    let requirements: Vec<String> = snapshot
        .requirements
        .iter()
        .filter(|spec| marker_applies(spec, &marker_env))
        .cloned()
        .collect();
    tracing::debug!(?requirements, "resolver_requirements");
    let request = ResolverRequest {
        project: snapshot.name.clone(),
        requirements,
        tags: ResolverTags {
            python: tags.python.clone(),
            abi: tags.abi.clone(),
            platform: tags.platform.clone(),
        },
        env: resolver_env.clone(),
        indexes: resolver_indexes(),
        cache_dir,
        python: python.clone(),
    };
    let resolved = resolve(&request).map_err(|err| {
        InstallUserError::new(
            "dependency resolution failed",
            resolver_failure_details(&err),
        )
    })?;
    let mut pins = Vec::new();
    let mut autopin_lookup = HashMap::new();
    let mut seen = HashSet::new();
    for spec in resolved {
        let formatted = format_specifier(
            &spec.normalized,
            &spec.extras,
            &spec.selected_version,
            spec.marker.as_deref(),
        );
        let pin = PinSpec {
            name: spec.name,
            specifier: formatted.clone(),
            version: spec.selected_version,
            normalized: spec.normalized,
            extras: spec.extras,
            marker: spec.marker,
            direct: spec.direct,
            requires: spec.requires,
        };
        autopin_lookup.insert(autopin_pin_key(&pin), formatted);
        if seen.insert(pin.normalized.clone()) {
            pins.push(pin);
        }
    }

    let mut autopin_specs = Vec::new();
    for spec in &snapshot.dependencies {
        if spec_requires_pin(spec) && marker_applies(spec, &marker_env) {
            let key = autopin_spec_key(spec);
            if let Some(pinned) = autopin_lookup.get(&key) {
                autopin_specs.push(pinned.clone());
            } else {
                autopin_specs.push(spec.clone());
            }
        }
    }
    if let Some(spinner) = spinner {
        spinner.finish(format!("Resolved {} dependencies", pins.len()));
    }
    Ok(ResolvedSpecOutput {
        specs: autopin_specs,
        pins,
    })
}

fn resolver_indexes() -> Vec<String> {
    let mut indexes = Vec::new();
    if let Ok(primary) = env::var("PX_INDEX_URL")
        .or_else(|_| env::var("PIP_INDEX_URL"))
        .map(|value| value.trim().to_string())
    {
        if !primary.is_empty() {
            indexes.push(normalize_index_url(&primary));
        }
    }
    if let Ok(extra) = env::var("PIP_EXTRA_INDEX_URL") {
        for entry in extra.split_whitespace() {
            let trimmed = entry.trim();
            if !trimmed.is_empty() {
                indexes.push(normalize_index_url(trimmed));
            }
        }
    }
    if indexes.is_empty() {
        indexes.push("https://pypi.org/simple".to_string());
    }
    indexes
}

fn normalize_index_url(raw: &str) -> String {
    let mut url = raw.trim_end_matches('/').to_string();
    if url.ends_with("/simple") {
        return url;
    }
    if let Some(stripped) = url.strip_suffix("/pypi") {
        url = stripped.to_string();
    } else if let Some(stripped) = url.strip_suffix("/json") {
        url = stripped.to_string();
    }
    url.push_str("/simple");
    url
}

fn resolver_failure_details(err: &anyhow::Error) -> Value {
    let message = err.to_string();
    let mut issues = vec![message.clone()];
    issues.extend(err.chain().skip(1).map(std::string::ToString::to_string));
    let details = json!({
        "reason": "resolve_failed",
        "issues": issues,
        "hint": "Inspect dependency constraints and rerun `px sync`.",
        "code": diag_commands::SYNC,
    });
    if let Some(req) = extract_quoted_requirement(&message) {
        if message.contains("unable to resolve") {
            return json!({
                "reason": "resolve_no_match",
                "issues": issues,
                "requirement": req,
                "hint": format!("Relax or remove `{}` in pyproject.toml, then rerun `px sync`.", req),
                "code": diag_commands::SYNC,
            });
        }
        if message.contains("failed to parse requirement")
            || message.contains("failed to parse specifiers")
        {
            return json!({
                "reason": "invalid_requirement",
                "issues": issues,
                "requirement": req,
                "hint": format!("Fix `{}` to a valid PEP 508 requirement, then rerun `px sync`.", req),
                "code": diag_commands::SYNC,
            });
        }
    }
    if message.contains("failed to query PyPI") || message.contains("PyPI error") {
        return json!({
            "reason": "pypi_unreachable",
            "issues": issues,
            "hint": "Check your network connection (PX_ONLINE=1) and rerun `px sync`.",
            "code": diag_commands::SYNC,
        });
    }
    details
}

fn extract_quoted_requirement(message: &str) -> Option<String> {
    let start = message.find('`')?;
    let rest = &message[start + 1..];
    let end = rest.find('`')?;
    Some(rest[..end].to_string())
}

pub(crate) fn persist_resolved_dependencies(
    snapshot: &ManifestSnapshot,
    specs: &[String],
) -> Result<()> {
    let contents = fs::read_to_string(&snapshot.manifest_path)?;
    let mut doc: DocumentMut = contents.parse()?;
    write_dependencies(&mut doc, specs)?;
    fs::write(&snapshot.manifest_path, doc.to_string())?;
    Ok(())
}

pub(crate) fn summarize_autopins(entries: &[AutopinEntry]) -> Option<String> {
    if entries.is_empty() {
        return None;
    }
    let mut labels = Vec::new();
    for entry in entries.iter().take(3) {
        labels.push(entry.short_label());
    }
    let mut summary = format!(
        "Pinned {} package{} automatically",
        entries.len(),
        if entries.len() == 1 { "" } else { "s" }
    );
    if !labels.is_empty() {
        summary.push_str(" (");
        summary.push_str(&labels.join(", "));
        if entries.len() > 3 {
            let _ = write!(&mut summary, ", +{} more", entries.len() - 3);
        }
        summary.push(')');
    }
    Some(summary)
}

fn write_dependencies(doc: &mut DocumentMut, specs: &[String]) -> Result<()> {
    let table = project_table_mut(doc)?;
    let mut array = Array::new();
    for spec in specs {
        array.push_formatted(TomlValue::from(spec.clone()));
    }
    table.insert("dependencies", Item::Value(TomlValue::Array(array)));
    Ok(())
}

pub(crate) fn project_table(doc: &DocumentMut) -> Result<&Table> {
    doc.get("project")
        .and_then(Item::as_table)
        .ok_or_else(|| anyhow!("[project] must be a table"))
}

fn project_table_mut(doc: &mut DocumentMut) -> Result<&mut Table> {
    doc.entry("project")
        .or_insert(Item::Table(Table::new()))
        .as_table_mut()
        .ok_or_else(|| anyhow!("[project] must be a table"))
}

pub(crate) fn outcome_from_output(
    command_name: &str,
    target: &str,
    output: &RunOutput,
    prefix: &str,
    extra: Option<Value>,
) -> ExecutionOutcome {
    let mut extra_details = extra;
    let context = TracebackContext::new(command_name, target, extra_details.as_ref());
    let mut details = json!({
        "stdout": output.stdout.clone(),
        "stderr": output.stderr.clone(),
        "code": output.code,
        "target": target,
    });

    if let Some(extra_value) = extra_details.take() {
        if let Value::Object(map) = extra_value {
            if let Some(details_map) = details.as_object_mut() {
                for (key, value) in map {
                    details_map.insert(key, value);
                }
            }
        } else {
            details["extra"] = extra_value;
        }
    }

    let mut has_traceback = false;
    if output.code != 0 {
        if let Some(report) = analyze_python_traceback(&output.stderr, &context) {
            has_traceback = true;
            let recommendation = report.recommendation.clone();
            let trace_value = serde_json::to_value(&report).expect("traceback serialization");
            if let Some(map) = details.as_object_mut() {
                map.insert("traceback".to_string(), trace_value);
            }
            if let Some(rec) = recommendation {
                let hint_text = rec.hint.clone();
                let rec_value = serde_json::to_value(&rec).expect("traceback recommendation");
                if let Some(map) = details.as_object_mut() {
                    map.insert("recommendation".to_string(), rec_value);
                    if !map.contains_key("hint") {
                        map.insert("hint".to_string(), Value::String(hint_text));
                    }
                }
            }
        }
    }

    if output.code == 0 {
        let stdout = output.stdout.trim_end();
        if !stdout.is_empty() {
            details["passthrough"] = Value::Bool(true);
            return ExecutionOutcome::success(stdout.to_string(), details);
        }
        let stderr = output.stderr.trim_end();
        if !stderr.is_empty() {
            details["passthrough"] = Value::Bool(true);
            return ExecutionOutcome::success(stderr.to_string(), details);
        }
        let message = format!("{prefix} {command_name}({target}) succeeded");
        ExecutionOutcome::success(message, details)
    } else {
        let trimmed_stderr = output.stderr.trim();
        let message = if trimmed_stderr.is_empty() || has_traceback {
            format!(
                "{prefix} {command_name}({target}) exited with {}",
                output.code
            )
        } else {
            details["passthrough"] = Value::Bool(true);
            output.stderr.trim_end().to_string()
        };
        ExecutionOutcome::failure(message, details)
    }
}

pub(crate) struct PythonContext {
    pub(crate) project_root: PathBuf,
    pub(crate) python: String,
    pub(crate) pythonpath: String,
    pub(crate) allowed_paths: Vec<PathBuf>,
    pub(crate) site_bin: Option<PathBuf>,
    pub(crate) pep582_bin: Vec<PathBuf>,
    pub(crate) px_options: PxOptions,
}

#[derive(Clone, Copy, Debug)]
pub(crate) enum EnvGuard {
    Strict,
    AutoSync,
}

#[derive(Clone, Debug)]
pub(crate) struct EnvironmentSyncReport {
    action: &'static str,
    note: String,
}

impl EnvironmentSyncReport {
    pub(crate) fn new(issue: EnvironmentIssue) -> Self {
        Self {
            action: issue.action_key(),
            note: issue.note().to_string(),
        }
    }

    fn to_json(&self) -> Value {
        json!({
            "action": self.action,
            "note": self.note,
        })
    }
}

#[derive(Clone, Copy, Debug)]
pub(crate) enum EnvironmentIssue {
    MissingLock,
    LockDrift,
    MissingArtifacts,
    MissingEnv,
    EnvOutdated,
    RuntimeMismatch,
}

impl EnvironmentIssue {
    fn from_details(details: &Value) -> Option<Self> {
        let reason = details
            .as_object()
            .and_then(|map| map.get("reason"))
            .and_then(Value::as_str)?;
        match reason {
            "missing_lock" => Some(EnvironmentIssue::MissingLock),
            "lock_drift" => Some(EnvironmentIssue::LockDrift),
            "missing_artifacts" => Some(EnvironmentIssue::MissingArtifacts),
            "missing_env" => Some(EnvironmentIssue::MissingEnv),
            "env_outdated" => Some(EnvironmentIssue::EnvOutdated),
            "runtime_mismatch" => Some(EnvironmentIssue::RuntimeMismatch),
            _ => None,
        }
    }

    fn note(self) -> &'static str {
        match self {
            EnvironmentIssue::MissingLock => "No px.lock found, resolving dependencies…",
            EnvironmentIssue::LockDrift => {
                "Manifest drift detected; syncing px.lock and environment…"
            }
            EnvironmentIssue::MissingArtifacts => {
                "Cached artifacts missing; rehydrating environment…"
            }
            EnvironmentIssue::MissingEnv => "Environment missing; rebuilding from px.lock…",
            EnvironmentIssue::EnvOutdated => {
                "Environment stale; syncing with latest lock and runtime…"
            }
            EnvironmentIssue::RuntimeMismatch => {
                "Environment runtime mismatch; rebuilding for current Python…"
            }
        }
    }

    fn action_key(self) -> &'static str {
        match self {
            EnvironmentIssue::MissingLock => "lock-bootstrap",
            EnvironmentIssue::LockDrift => "lock-sync",
            EnvironmentIssue::MissingArtifacts => "env-rehydrate",
            EnvironmentIssue::MissingEnv => "env-recreate",
            EnvironmentIssue::EnvOutdated => "env-refresh",
            EnvironmentIssue::RuntimeMismatch => "env-runtime",
        }
    }

    fn auto_fixable(self) -> bool {
        matches!(
            self,
            EnvironmentIssue::MissingArtifacts
                | EnvironmentIssue::MissingEnv
                | EnvironmentIssue::EnvOutdated
                | EnvironmentIssue::RuntimeMismatch
        )
    }
}
#[allow(dead_code)]
pub(crate) fn issue_from_details(details: &Value) -> Option<EnvironmentIssue> {
    EnvironmentIssue::from_details(details)
}

impl PythonContext {
    fn new_with_guard(
        ctx: &CommandContext,
        guard: EnvGuard,
    ) -> Result<(Self, Option<EnvironmentSyncReport>)> {
        let project_root = ctx.project_root()?;
        let manifest_path = project_root.join("pyproject.toml");
        if !manifest_path.exists() {
            return Err(InstallUserError::new(
                format!("pyproject.toml not found in {}", project_root.display()),
                json!({
                    "pyproject": manifest_path.display().to_string(),
                    "hint": "run `px migrate --apply` or create pyproject.toml first",
                    "reason": "missing_manifest",
                }),
            )
            .into());
        }
        ensure_version_file(&manifest_path)?;
        let snapshot = manifest_snapshot_at(&project_root)?;
        let runtime = prepare_project_runtime(&snapshot)?;
        let sync_report = ensure_environment_with_guard(ctx, &snapshot, guard)?;
        let paths = build_pythonpath(ctx.fs(), &project_root, None)?;
        let python = select_python_from_site(
            &paths.site_bin,
            &runtime.record.path,
            &runtime.record.full_version,
        );
        Ok((
            Self {
                project_root,
                python,
                pythonpath: paths.pythonpath,
                allowed_paths: paths.allowed_paths,
                site_bin: paths.site_bin,
                pep582_bin: paths.pep582_bin,
                px_options: snapshot.px_options.clone(),
            },
            sync_report,
        ))
    }

    pub(crate) fn base_env(&self, command_args: &Value) -> Result<Vec<(String, String)>> {
        let mut envs = Vec::new();
        envs.push(("PYTHONPATH".into(), self.pythonpath.clone()));
        envs.push(("PYTHONUNBUFFERED".into(), "1".into()));
        let allowed =
            env::join_paths(&self.allowed_paths).context("allowed path contains invalid UTF-8")?;
        let allowed = allowed
            .into_string()
            .map_err(|_| anyhow!("allowed path contains non-utf8 data"))?;
        envs.push(("PX_ALLOWED_PATHS".into(), allowed));
        envs.push((
            "PX_PROJECT_ROOT".into(),
            self.project_root.display().to_string(),
        ));
        envs.push(("PX_PYTHON".into(), self.python.clone()));
        envs.push(("PX_COMMAND_JSON".into(), command_args.to_string()));
        if let Some(alias) = self.px_options.manage_command.as_ref() {
            let trimmed = alias.trim();
            if !trimmed.is_empty() {
                envs.push(("PYAPP_COMMAND_NAME".into(), trimmed.to_string()));
            }
        }
        if let Some(bin) = &self.site_bin {
            if let Some(site_dir) = bin.parent() {
                let virtual_env = site_dir
                    .canonicalize()
                    .unwrap_or_else(|_| site_dir.to_path_buf());
                envs.push(("VIRTUAL_ENV".into(), virtual_env.display().to_string()));
            }
        }
        let mut path_entries = Vec::new();
        if let Some(bin) = &self.site_bin {
            path_entries.push(bin.clone());
        }
        path_entries.extend(self.pep582_bin.iter().cloned());
        if let Some(python_dir) = Path::new(&self.python).parent() {
            path_entries.push(python_dir.to_path_buf());
        }
        if let Ok(existing) = env::var("PATH") {
            path_entries.extend(env::split_paths(&existing));
        }
        let mut unique = Vec::new();
        let mut seen = std::collections::HashSet::new();
        for entry in path_entries.into_iter().filter(|p| p.exists()) {
            if seen.insert(entry.clone()) {
                unique.push(entry);
            }
        }
        if !unique.is_empty() {
            if let Ok(joined) = env::join_paths(&unique) {
                if let Ok(value) = joined.into_string() {
                    envs.push(("PATH".into(), value));
                }
            }
        }
        disable_proxy_env(&mut envs);
        Ok(envs)
    }
}

pub(crate) fn ensure_version_file(manifest_path: &Path) -> Result<()> {
    let contents = fs::read_to_string(manifest_path)?;
    let doc: toml_edit::DocumentMut = contents.parse()?;
    let Some(hooks) = doc
        .get("tool")
        .and_then(|tool| tool.get("hatch"))
        .and_then(|hatch| hatch.get("build"))
        .and_then(|build| build.get("hooks"))
        .and_then(|hooks| hooks.get("vcs"))
    else {
        return Ok(());
    };
    let Some(version_file) = hooks
        .get("version-file")
        .and_then(|item| item.as_str())
        .map(PathBuf::from)
    else {
        return Ok(());
    };
    let version_path = manifest_path
        .parent()
        .unwrap_or_else(|| Path::new("."))
        .join(version_file);
    if version_path.exists() {
        return Ok(());
    }
    if let Some(parent) = version_path.parent() {
        fs::create_dir_all(parent)?;
    }
    let derived = match derive_vcs_version(manifest_path.parent().unwrap_or_else(|| Path::new(".")))
    {
        Ok(version) => version,
        Err(err) => {
            warn!(
                error = %err,
                path = %manifest_path.display(),
                "git metadata unavailable; writing fallback vcs version"
            );
            "0.0.0+unknown".to_string()
        }
    };
    fs::write(&version_path, format!("__version__ = \"{derived}\"\n"))?;
    Ok(())
}

fn derive_vcs_version(manifest_dir: &Path) -> Result<String> {
    if let Ok(output) = Command::new("git")
        .args(["describe", "--tags", "--dirty", "--long"])
        .current_dir(manifest_dir)
        .output()
    {
        if output.status.success() {
            let desc = String::from_utf8_lossy(&output.stdout).trim().to_string();
            if let Some(version) = pep440_from_describe(&desc) {
                return Ok(version);
            }
        }
    }

    if let Ok(output) = Command::new("git")
        .args(["rev-parse", "--short", "HEAD"])
        .current_dir(manifest_dir)
        .output()
    {
        if output.status.success() {
            let hash = String::from_utf8_lossy(&output.stdout)
                .trim()
                .trim_start_matches('g')
                .to_string();
            if !hash.is_empty() {
                return Ok(format!("0.0.0+g{hash}"));
            }
        }
    }

    Err(anyhow!(
        "unable to derive version from git; add tags or version-file"
    ))
}

fn pep440_from_describe(desc: &str) -> Option<String> {
    let trimmed = desc.trim();
    if trimmed.is_empty() {
        return None;
    }
    let mut dirty = false;
    let mut core = trimmed.to_string();
    if core.ends_with("-dirty") {
        dirty = true;
        core = core.trim_end_matches("-dirty").to_string();
    }
    let mut iter = core.rsplitn(3, '-');
    let sha_part = iter.next()?;
    let commits_part = iter.next()?;
    let tag_part = iter.next()?;

    let sha = sha_part.trim_start_matches('g');
    let tag = tag_part.trim_start_matches('v');
    let mut version = format!("{tag}+{commits_part}.g{sha}");
    if dirty {
        version.push_str(".dirty");
    }
    Some(version)
}

pub(crate) struct PythonPathInfo {
    pub(crate) pythonpath: String,
    pub(crate) allowed_paths: Vec<PathBuf>,
    pub(crate) site_bin: Option<PathBuf>,
    pub(crate) pep582_bin: Vec<PathBuf>,
}

pub(crate) fn build_pythonpath(
    fs: &dyn effects::FileSystem,
    project_root: &Path,
    site_override: Option<PathBuf>,
) -> Result<PythonPathInfo> {
    let mut site_paths = Vec::new();
    let mut site_dir_used = None;

    if let Some(site_dir) =
        site_override.or_else(|| resolve_project_site(fs, project_root).ok().flatten())
    {
        let canonical = fs.canonicalize(&site_dir).unwrap_or(site_dir.clone());
        site_dir_used = Some(canonical.clone());
        site_paths.push(canonical.clone());
        let pth = canonical.join("px.pth");
        if pth.exists() {
            if let Ok(contents) = fs.read_to_string(&pth) {
                for line in contents.lines() {
                    let trimmed = line.trim();
                    if trimmed.is_empty() {
                        continue;
                    }
                    let entry_path = PathBuf::from(trimmed);
                    if entry_path.exists() {
                        site_paths.push(entry_path);
                    }
                }
            }
        }
    }

    let mut project_paths = Vec::new();
    let src = project_root.join("src");
    if src.exists() {
        project_paths.push(src);
    }
    let python_dir = project_root.join("python");
    if python_dir.exists() {
        project_paths.push(python_dir);
    }
    let mut child_projects = Vec::new();
    if let Ok(entries) = fs.read_dir(project_root) {
        for entry in entries.flatten() {
            let path = entry.path();
            if !path.is_dir() {
                continue;
            }
            let manifest = path.join("pyproject.toml");
            if fs.metadata(&manifest).is_ok() {
                child_projects.push(path);
            }
        }
    }
    child_projects.sort();
    for path in child_projects {
        if path != project_root {
            project_paths.push(path);
        }
    }
    project_paths.push(project_root.to_path_buf());

    let mut pep582_libs = Vec::new();
    let mut pep582_bins = Vec::new();
    let pep582_root = project_root.join("__pypackages__");
    if pep582_root.exists() {
        if let Ok(entries) = fs.read_dir(&pep582_root) {
            for entry in entries.flatten() {
                let path = entry.path();
                if !path.is_dir() {
                    continue;
                }
                let lib = path.join("lib");
                if lib.exists() {
                    pep582_libs.push(lib);
                } else {
                    pep582_libs.push(path.clone());
                }
                let bin = path.join("bin");
                if bin.exists() {
                    pep582_bins.push(bin);
                }
            }
        }
    }

    let mut paths = Vec::new();
    if let Some(dir) = site_dir_used.as_ref() {
        paths.push(dir.clone());
    }
    paths.extend(project_paths);
    paths.extend(pep582_libs);
    for path in site_paths {
        if Some(&path) != site_dir_used.as_ref() {
            paths.push(path);
        }
    }
    paths.retain(|p| p.exists());
    if paths.is_empty() {
        paths.push(project_root.to_path_buf());
    }

    let joined = env::join_paths(&paths).context("failed to build PYTHONPATH")?;
    let pythonpath = joined
        .into_string()
        .map_err(|_| anyhow!("pythonpath contains non-UTF paths"))?;
    let site_bin = site_dir_used
        .map(|dir| dir.join("bin"))
        .filter(|bin| bin.exists());
    Ok(PythonPathInfo {
        pythonpath,
        allowed_paths: paths,
        site_bin,
        pep582_bin: pep582_bins,
    })
}

pub(crate) fn ensure_project_environment_synced(
    ctx: &CommandContext,
    snapshot: &ManifestSnapshot,
) -> Result<()> {
    if !snapshot.manifest_path.exists() {
        return Err(InstallUserError::new(
            format!("pyproject.toml not found in {}", snapshot.root.display()),
            json!({
                "hint": "run `px migrate --apply` or pass ENTRY explicitly",
                "project_root": snapshot.root.display().to_string(),
                "manifest": snapshot.manifest_path.display().to_string(),
                "reason": "missing_manifest",
            }),
        )
        .into());
    }
    let lock_path = snapshot.lock_path.clone();
    let Some(lock) = load_lockfile_optional(&lock_path)? else {
        return Err(InstallUserError::new(
            "missing px.lock (run `px sync`)",
            json!({
                "lockfile": lock_path.display().to_string(),
                "hint": "run `px sync` to generate px.lock before running this command",
                "reason": "missing_lock",
            }),
        )
        .into());
    };

    let runtime = prepare_project_runtime(snapshot)?;
    let marker_env = detect_marker_environment(&runtime.record.path)?.to_marker_environment()?;

    let drift = detect_lock_drift(snapshot, &lock, Some(&marker_env));
    if !drift.is_empty() {
        return Err(InstallUserError::new(
            "px.lock is out of date",
            json!({
                "lockfile": lock_path.display().to_string(),
                "drift": drift,
                "hint": "run `px sync` to refresh px.lock",
                "reason": "lock_drift",
            }),
        )
        .into());
    }

    let missing = verify_locked_artifacts(&lock);
    if !missing.is_empty() {
        return Err(InstallUserError::new(
            "cached artifacts missing",
            json!({
                "lockfile": lock_path.display().to_string(),
                "missing": missing,
                "hint": "run `px sync` to rehydrate the environment",
                "reason": "missing_artifacts",
            }),
        )
        .into());
    }

    let lock_id = match lock.lock_id.clone() {
        Some(value) => value,
        None => compute_lock_hash(&lock_path)?,
    };
    ensure_env_matches_lock(ctx, snapshot, &lock_id)
}

pub fn ensure_env_matches_lock(
    ctx: &CommandContext,
    snapshot: &ManifestSnapshot,
    lock_id: &str,
) -> Result<()> {
    let state = match load_project_state(ctx.fs(), &snapshot.root) {
        Ok(state) => state,
        Err(err) => {
            return Err(InstallUserError::new(
                "px state file is unreadable",
                json!({
                    "error": err.to_string(),
                    "state": snapshot.root.join(".px").join("state.json"),
                    "hint": "Repair or delete the corrupted .px/state.json file, then rerun the command.",
                    "reason": "invalid_state",
                }),
            )
            .into());
        }
    };
    let Some(env) = state.current_env else {
        return Err(InstallUserError::new(
            "project environment missing",
            json!({
                "hint": "run `px sync` to build the environment",
                "reason": "missing_env",
            }),
        )
        .into());
    };
    if env.lock_id != lock_id {
        return Err(InstallUserError::new(
            "environment is out of date",
            json!({
                "expected_lock_id": lock_id,
                "current_lock_id": env.lock_id,
                "hint": "run `px sync` to rebuild the environment",
                "reason": "env_outdated",
            }),
        )
        .into());
    }
    let site_dir = PathBuf::from(&env.site_packages);
    if !site_dir.exists() {
        return Err(InstallUserError::new(
            "environment files missing",
            json!({
                "site": env.site_packages,
                "hint": "run `px sync` to rebuild the environment",
                "reason": "missing_env",
            }),
        )
        .into());
    }

    let runtime = detect_runtime_metadata(ctx, snapshot)?;
    if runtime.version != env.python.version || runtime.platform != env.platform {
        return Err(InstallUserError::new(
            format!(
                "environment targets Python {} ({}) but {} ({}) is active",
                env.python.version, env.platform, runtime.version, runtime.platform
            ),
            json!({
                "expected_python": env.python.version,
                "current_python": runtime.version,
                "expected_platform": env.platform,
                "current_platform": runtime.platform,
                "hint": "run `px sync` to rebuild for the current runtime",
                "reason": "runtime_mismatch",
            }),
        )
        .into());
    }

    Ok(())
}

fn ensure_environment_with_guard(
    ctx: &CommandContext,
    snapshot: &ManifestSnapshot,
    guard: EnvGuard,
) -> Result<Option<EnvironmentSyncReport>> {
    match ensure_project_environment_synced(ctx, snapshot) {
        Ok(()) => Ok(None),
        Err(err) => match err.downcast::<InstallUserError>() {
            Ok(user) => match guard {
                EnvGuard::Strict => Err(user.into()),
                EnvGuard::AutoSync => {
                    if let Some(issue) = EnvironmentIssue::from_details(&user.details) {
                        if issue.auto_fixable() {
                            auto_sync_environment(ctx, snapshot, issue)
                        } else {
                            Err(user.into())
                        }
                    } else {
                        Err(user.into())
                    }
                }
            },
            Err(err) => Err(err),
        },
    }
}

pub(crate) fn auto_sync_environment(
    ctx: &CommandContext,
    snapshot: &ManifestSnapshot,
    issue: EnvironmentIssue,
) -> Result<Option<EnvironmentSyncReport>> {
    install_snapshot(ctx, snapshot, false, None)?;
    refresh_project_site(snapshot, ctx)?;
    Ok(Some(EnvironmentSyncReport::new(issue)))
}

pub(crate) fn attach_autosync_details(
    outcome: &mut ExecutionOutcome,
    report: Option<EnvironmentSyncReport>,
) {
    let Some(report) = report else {
        return;
    };
    let autosync = report.to_json();
    match outcome.details {
        Value::Object(ref mut map) => {
            map.insert("autosync".to_string(), autosync);
        }
        Value::Null => {
            outcome.details = json!({ "autosync": autosync });
        }
        ref mut other => {
            let previous = other.take();
            outcome.details = json!({
                "value": previous,
                "autosync": autosync,
            });
        }
    }
}

pub(crate) fn python_context(ctx: &CommandContext) -> Result<PythonContext, ExecutionOutcome> {
    python_context_with_mode(ctx, EnvGuard::Strict).map(|(py, _)| py)
}

pub(crate) fn python_context_with_mode(
    ctx: &CommandContext,
    guard: EnvGuard,
) -> Result<(PythonContext, Option<EnvironmentSyncReport>), ExecutionOutcome> {
    match PythonContext::new_with_guard(ctx, guard) {
        Ok(result) => Ok(result),
        Err(err) => {
            if is_missing_project_error(&err) {
                return Err(missing_project_outcome());
            }
            match err.downcast::<InstallUserError>() {
                Ok(user) => Err(ExecutionOutcome::user_error(user.message, user.details)),
                Err(err) => Err(ExecutionOutcome::failure(
                    "failed to prepare python environment",
                    json!({ "error": err.to_string() }),
                )),
            }
        }
    }
}

pub fn missing_project_outcome() -> ExecutionOutcome {
    ExecutionOutcome::user_error(
        MISSING_PROJECT_MESSAGE,
        json!({
            "reason": "missing_project",
            "hint": MISSING_PROJECT_HINT,
        }),
    )
}

pub fn is_missing_project_error(err: &anyhow::Error) -> bool {
    err.chain()
        .any(|cause| cause.to_string().contains("No px project found"))
}

pub fn manifest_error_outcome(err: &anyhow::Error) -> Option<ExecutionOutcome> {
    if err
        .chain()
        .any(|cause| cause.to_string().contains("pyproject.toml not found"))
    {
        return Some(ExecutionOutcome::user_error(
            "pyproject.toml not found",
            json!({
                "reason": "missing_manifest",
                "hint": "Run `px init` to create pyproject.toml, or restore it from version control.",
            }),
        ));
    }

    let parse_error = err
        .chain()
        .find_map(|cause| cause.downcast_ref::<TomlError>().map(ToString::to_string))?;

    let mut target = "pyproject.toml";
    for cause in err.chain() {
        let msg = cause.to_string();
        if msg.contains("px.lock") {
            target = "px.lock";
            break;
        }
        if msg.contains("pyproject.toml") {
            target = "pyproject.toml";
            break;
        }
    }

    let (reason, hint) = if target == "px.lock" {
        (
            "invalid_lock",
            "Delete or fix px.lock, then run `px sync` to regenerate it.",
        )
    } else {
        (
            "invalid_manifest",
            "Fix pyproject.toml syntax and rerun the command.",
        )
    };

    Some(ExecutionOutcome::user_error(
        format!("{target} is not valid TOML"),
        json!({
            "reason": reason,
            "target": target,
            "error": parse_error,
            "hint": hint,
        }),
    ))
}

#[must_use]
pub fn to_json_response(info: CommandInfo, outcome: &ExecutionOutcome, _code: i32) -> Value {
    let status = match outcome.status {
        CommandStatus::Ok => "ok",
        CommandStatus::UserError => "user-error",
        CommandStatus::Failure => "error",
    };
    let details = match &outcome.details {
        Value::Object(_) => outcome.details.clone(),
        Value::Null => json!({}),
        other => json!({ "value": other }),
    };
    json!({
        "status": status,
        "message": format_status_message(info, &outcome.message),
        "details": details,
    })
}

#[must_use]
pub fn format_status_message(info: CommandInfo, message: &str) -> String {
    let group_name = info.group.to_string();
    let prefix = if group_name == info.name {
        format!("px {}", info.name)
    } else {
        format!("px {} {}", group_name, info.name)
    };
    if message.is_empty() {
        prefix
    } else if message.starts_with(&prefix) {
        message.to_string()
    } else {
        format!("{prefix}: {message}")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::SystemEffects;
    use anyhow::Result;
    use serde_json::Value;
    use std::env;
    use std::fs;
    use std::io::Write;
    use std::path::Path;
    use std::process::Command;
    use tempfile::tempdir;
    use zip::write::FileOptions;

    #[test]
    fn materialize_scripts_from_dist_directory() -> Result<()> {
        let temp = tempdir()?;
        let artifact = temp.path().join("demo-0.1.0.dist");
        let dist_info = artifact.join("demo-0.1.0.dist-info");
        let data_scripts = artifact.join("demo-0.1.0.data").join("scripts");
        fs::create_dir_all(&dist_info)?;
        fs::create_dir_all(&data_scripts)?;
        fs::write(
            dist_info.join("entry_points.txt"),
            "[console_scripts]\nalpha = demo.cli:main\n[gui_scripts]\nbeta = demo.gui:run\n",
        )?;
        fs::write(data_scripts.join("copied.sh"), "echo copied\n")?;

        let bin_dir = temp.path().join("bin");
        materialize_wheel_scripts(&artifact, &bin_dir, Some(Path::new("/custom/python")))?;

        let alpha = fs::read_to_string(bin_dir.join("alpha"))?;
        assert!(
            alpha.starts_with("#!/custom/python"),
            "shebang honors python"
        );
        assert!(alpha.contains("demo.cli"));
        let beta = fs::read_to_string(bin_dir.join("beta"))?;
        assert!(beta.contains("demo.gui"));
        let copied = fs::read_to_string(bin_dir.join("copied.sh"))?;
        assert!(copied.contains("copied"));
        Ok(())
    }

    #[test]
    fn materialize_scripts_from_wheel_file() -> Result<()> {
        let temp = tempdir()?;
        let wheel_path = temp.path().join("demo-0.2.0-py3-none-any.whl");
        let file = fs::File::create(&wheel_path)?;
        let mut zip = zip::ZipWriter::new(file);
        let opts = FileOptions::default();
        zip.start_file("demo-0.2.0.dist-info/entry_points.txt", opts)?;
        zip.write_all(b"[console_scripts]\ngamma = demo.core:run\n")?;
        zip.start_file("demo-0.2.0.data/scripts/helper.sh", opts)?;
        zip.write_all(b"echo helper\n")?;
        zip.finish()?;

        let bin_dir = temp.path().join("wheel-bin");
        materialize_wheel_scripts(&wheel_path, &bin_dir, None)?;

        let gamma = fs::read_to_string(bin_dir.join("gamma"))?;
        assert!(gamma.starts_with("#!/usr/bin/env python3"));
        assert!(gamma.contains("demo.core"));
        let helper = fs::read_to_string(bin_dir.join("helper.sh"))?;
        assert!(helper.contains("helper"));
        Ok(())
    }

    #[test]
    fn site_dir_precedes_project_root_in_sys_path() -> Result<()> {
        let temp = tempdir()?;
        let project_root = temp.path();
        let site_dir = project_root.join("site");
        fs::create_dir_all(&site_dir)?;
        fs::write(site_dir.join("sitecustomize.py"), SITE_CUSTOMIZE)?;

        let dep_pkg = site_dir.join("deps");
        let dep_mod = dep_pkg.join("dep");
        fs::create_dir_all(&dep_mod)?;
        fs::write(dep_mod.join("__init__.py"), "VALUE = 'site'\n")?;
        fs::write(site_dir.join("px.pth"), format!("{}\n", dep_pkg.display()))?;

        // Namespace-like directory at the project root should not shadow site packages
        fs::create_dir_all(project_root.join("dep"))?;

        let effects = SystemEffects::new();
        let paths = build_pythonpath(effects.fs(), project_root, Some(site_dir.clone()))?;
        let allowed = env::join_paths(&paths.allowed_paths)
            .expect("allowed paths")
            .into_string()
            .expect("utf8 allowed paths");
        let allowed_env = allowed.clone();
        let python = match effects.python().detect_interpreter() {
            Ok(path) => path,
            Err(_) => return Ok(()),
        };

        let mut cmd = Command::new(&python);
        cmd.current_dir(project_root);
        cmd.env("PYTHONPATH", paths.pythonpath.clone());
        cmd.env("PX_ALLOWED_PATHS", allowed_env.clone());
        cmd.arg("-c").arg(
            "import importlib, json, os, sys; mod = importlib.import_module('dep'); \
             print(json.dumps({'file': getattr(mod, '__file__', ''), 'value': getattr(mod, 'VALUE', ''), 'prefix': sys.path[:3], 'env_py': os.environ.get('PYTHONPATH')}))",
        );
        let output = cmd.output()?;
        let stdout = String::from_utf8_lossy(&output.stdout);
        assert!(
            output.status.success(),
            "python exited with {}: {}\n{}",
            output.status,
            stdout,
            String::from_utf8_lossy(&output.stderr)
        );

        let payload: Value = serde_json::from_str(stdout.trim())?;
        let prefix: Vec<String> = payload
            .get("prefix")
            .and_then(Value::as_array)
            .map(|entries| {
                entries
                    .iter()
                    .filter_map(Value::as_str)
                    .map(std::string::ToString::to_string)
                    .collect()
            })
            .unwrap_or_default();
        let canonical_site = effects.fs().canonicalize(&site_dir)?;
        let canonical_site_str = canonical_site.display().to_string();
        let first_nonempty = if prefix.first().is_some_and(|entry| entry.is_empty()) {
            prefix.get(1).map(String::as_str)
        } else {
            prefix.first().map(String::as_str)
        };
        assert_eq!(first_nonempty, Some(canonical_site_str.as_str()));
        let value = payload
            .get("value")
            .and_then(Value::as_str)
            .unwrap_or_default();
        assert_eq!(value, "site");
        let env_py = payload
            .get("env_py")
            .and_then(Value::as_str)
            .unwrap_or_default();
        assert_eq!(env_py, allowed_env);
        let file = payload.get("file").and_then(Value::as_str).unwrap_or("");
        assert!(
            file.contains(dep_mod.to_string_lossy().as_ref()),
            "expected module to load from site packages, got {file}"
        );
        Ok(())
    }

    #[test]
    fn ensure_version_file_populates_missing_file_from_git() -> Result<()> {
        if Command::new("git").arg("--version").status().is_err() {
            return Ok(());
        }
        let temp = tempdir()?;
        let manifest = temp.path().join("pyproject.toml");
        fs::write(
            &manifest,
            r#"[project]
name = "demo"
version = "0.1.0"
requires-python = ">=3.11"

[tool.hatch.build.hooks.vcs]
version-file = "demo/_version.py"
"#,
        )?;
        let demo_dir = temp.path().join("demo");
        fs::create_dir_all(&demo_dir)?;
        fs::write(demo_dir.join("__init__.py"), "")?;

        if Command::new("git").arg("--version").output().is_err() {
            eprintln!("skipping version file test (git not available)");
            return Ok(());
        }

        assert!(
            Command::new("git")
                .arg("init")
                .current_dir(temp.path())
                .output()?
                .status
                .success(),
            "git init failed"
        );
        assert!(
            Command::new("git")
                .args(["config", "user.email", "ci@example.com"])
                .current_dir(temp.path())
                .output()?
                .status
                .success(),
            "git config email failed"
        );
        assert!(
            Command::new("git")
                .args(["config", "user.name", "CI"])
                .current_dir(temp.path())
                .output()?
                .status
                .success(),
            "git config name failed"
        );
        assert!(
            Command::new("git")
                .args(["add", "."])
                .current_dir(temp.path())
                .output()?
                .status
                .success(),
            "git add failed"
        );
        assert!(
            Command::new("git")
                .args(["commit", "-m", "init"])
                .current_dir(temp.path())
                .output()?
                .status
                .success(),
            "git commit failed"
        );

        ensure_version_file(&manifest)?;
        let contents = fs::read_to_string(temp.path().join("demo/_version.py"))?;
        assert!(
            contents.contains("__version__ = \"0.0.0+g"),
            "version file should be derived from git rev"
        );
        Ok(())
    }

    #[test]
    fn ensure_version_file_falls_back_without_git_metadata() -> Result<()> {
        let temp = tempdir()?;
        let manifest = temp.path().join("pyproject.toml");
        fs::write(
            &manifest,
            r#"[project]
name = "demo"
version = "0.1.0"
requires-python = ">=3.11"

[tool.hatch.build.hooks.vcs]
version-file = "demo/_version.py"
"#,
        )?;
        let demo_dir = temp.path().join("demo");
        fs::create_dir_all(&demo_dir)?;
        fs::write(demo_dir.join("__init__.py"), "")?;

        ensure_version_file(&manifest)?;
        let contents = fs::read_to_string(temp.path().join("demo/_version.py"))?;
        assert!(
            contents.contains("__version__ = \"0.0.0+unknown\""),
            "fallback version should be written when git metadata is missing"
        );
        Ok(())
    }

    #[test]
    fn pep440_from_describe_formats_dirty_and_tagged() {
        let version = pep440_from_describe("v1.2.3-4-gabc123").unwrap();
        assert_eq!(version, "1.2.3+4.gabc123");
        let dirty = pep440_from_describe("v0.1.0-0-gdeadbeef-dirty").unwrap();
        assert_eq!(dirty, "0.1.0+0.gdeadbeef.dirty");
    }

    #[test]
    fn pep440_from_describe_handles_tags_with_hyphens() {
        let version = pep440_from_describe("v1.2.3-beta.1-0-gabc123").unwrap();
        assert_eq!(version, "1.2.3-beta.1+0.gabc123");
    }
}
