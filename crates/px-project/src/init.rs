use std::{fs, path::Path};

use anyhow::{bail, Result};

use crate::manifest::relative_path;

pub struct ProjectInitializer;

impl ProjectInitializer {
    pub fn scaffold(root: &Path, package: &str, python_req: &str) -> Result<Vec<String>> {
        let mut files = Vec::new();
        let pyproject_path = root.join("pyproject.toml");
        let package_dir = root.join(package);
        let tests_dir = root.join("tests");

        fs::create_dir_all(&package_dir)?;
        fs::create_dir_all(&tests_dir)?;

        let script_name = format!("{package}-cli");
        let pyproject = format!("[project]\nname = \"{package}\"\nversion = \"0.1.0\"\n")
            + "description = \"Generated by px project init\"\n"
            + &format!("requires-python = \"{python_req}\"\n")
            + "dependencies = []\n\n[project.scripts]\n"
            + &format!("{script_name} = \"{package}.cli:main\"\n")
            + "\n[build-system]\n"
            + "requires = [\"setuptools>=70\", \"wheel\"]\n"
            + "build-backend = \"setuptools.build_meta\"\n";
        fs::write(&pyproject_path, pyproject)?;
        files.push(relative_path(root, &pyproject_path));

        let init_path = package_dir.join("__init__.py");
        fs::write(&init_path, "__all__ = [\"cli\"]\n")?;
        files.push(relative_path(root, &init_path));

        let cli_path = package_dir.join("cli.py");
        let cli_body = [
            "from __future__ import annotations",
            "",
            "def greet(name: str | None = None) -> str:",
            "    target = name or \"World\"",
            "    return f\"Hello, {target}!\"",
            "",
            "def main() -> None:",
            "    import argparse",
            "",
            "    parser = argparse.ArgumentParser(description=\"Print a greeting.\")",
            "    parser.add_argument(\"-n\", \"--name\", default=None, help=\"Name to greet\")",
            "    args = parser.parse_args()",
            "    print(greet(args.name))",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    main()",
            "",
        ]
        .join("\n");
        fs::write(&cli_path, cli_body)?;
        files.push(relative_path(root, &cli_path));

        let tests_path = tests_dir.join("test_cli.py");
        let tests_body = [
            &format!("from {package}.cli import greet"),
            "",
            "def test_greet_default() -> None:",
            "    assert greet() == \"Hello, World!\"",
            "",
            "def test_greet_name() -> None:",
            "    assert greet(\"Px\") == \"Hello, Px!\"",
            "",
        ]
        .join("\n");
        fs::write(&tests_path, tests_body)?;
        files.push(relative_path(root, &tests_path));

        ensure_gitignore(root, &mut files)?;

        Ok(files)
    }
}

pub fn infer_package_name(explicit: Option<&str>, root: &Path) -> Result<(String, bool)> {
    if let Some(name) = explicit {
        validate_package_name(name)?;
        return Ok((name.to_string(), false));
    }
    let inferred = sanitize_package_candidate(root);
    validate_package_name(&inferred)?;
    Ok((inferred, true))
}

pub fn sanitize_package_candidate(root: &Path) -> String {
    let raw = root
        .file_name()
        .and_then(|name| name.to_str())
        .unwrap_or("px_app");
    sanitize_package_name(raw)
}

fn sanitize_package_name(raw: &str) -> String {
    let mut result = String::new();
    let mut last_was_sep = false;
    for ch in raw.chars() {
        if ch.is_ascii_alphanumeric() {
            result.push(ch.to_ascii_lowercase());
            last_was_sep = false;
        } else if matches!(ch, '-' | '_' | ' ' | '.') {
            if !last_was_sep {
                result.push('_');
                last_was_sep = true;
            }
        } else {
            last_was_sep = false;
        }
    }
    while result.starts_with('_') {
        result.remove(0);
    }
    while result.ends_with('_') {
        result.pop();
    }
    if result.is_empty() {
        return "px_app".to_string();
    }
    let first = result.chars().next().unwrap();
    if !first.is_ascii_alphabetic() && first != '_' {
        result = format!("px_{result}");
    }
    result
}

fn ensure_gitignore(root: &Path, files: &mut Vec<String>) -> Result<()> {
    let path = root.join(".gitignore");
    let entries = ["__pycache__/", "dist/", "build/", "*.egg-info/"];
    if !path.exists() {
        let mut contents = String::new();
        for entry in &entries {
            contents.push_str(entry);
            contents.push('\n');
        }
        fs::write(&path, contents)?;
        files.push(relative_path(root, &path));
        return Ok(());
    }

    let mut contents = fs::read_to_string(&path)?;
    let mut changed = false;
    for entry in &entries {
        if !contents.lines().any(|line| line.trim() == *entry) {
            if !contents.ends_with('\n') {
                contents.push('\n');
            }
            contents.push_str(entry);
            contents.push('\n');
            changed = true;
        }
    }
    if changed {
        fs::write(&path, contents)?;
        files.push(relative_path(root, &path));
    }
    Ok(())
}

fn validate_package_name(name: &str) -> Result<()> {
    let mut chars = name.chars();
    match chars.next() {
        Some(ch) if ch.is_ascii_alphabetic() || ch == '_' => {}
        _ => bail!("package name must start with a letter or underscore"),
    }
    if !chars.all(|c| c.is_ascii_alphanumeric() || c == '_') {
        bail!("package name may only contain letters, numbers, or underscores");
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn sanitize_infers_reasonable_name() {
        let dir = tempdir().unwrap();
        let root = dir.path().join("Hello-World!");
        fs::create_dir_all(&root).unwrap();
        let name = sanitize_package_candidate(&root);
        assert_eq!(name, "hello_world");
    }
}
